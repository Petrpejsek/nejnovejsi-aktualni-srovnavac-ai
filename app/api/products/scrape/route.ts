import { NextResponse } from 'next/server';
import prisma from '../../../../lib/prisma';
import { NextRequest } from 'next/server';

interface ProductData {
  name: string;
  description: string;
  primary_category: string;
  secondary_category?: string;
  price: number;
  advantages: string[];
  disadvantages: string[];
  hasTrial: boolean;
  tags: string[];
  detailInfo: string;
  pricingInfo: any;
}

// Funkce pro normalizaci tag≈Ø
function normalizeTag(tag: string): string {
  const normalizedTag = tag.trim().toLowerCase()
  
  // Sjednot√≠me podobn√© tagy
  const tagMap: { [key: string]: string } = {
    'text na ≈ôeƒç': 'Text to Speech',
    'text to speech': 'Text to Speech',
    '√∫prava fotek': 'Image Editing',
    '√∫prava obr√°zk≈Ø': 'Image Editing',
    'generov√°n√≠ obr√°zk≈Ø': 'Image Generation',
    'generov√°n√≠ obr√°zk√∫': 'Image Generation',
    'z√°kaznick√Ω servis': 'Customer Support',
    'z√°kaznick√° podpora': 'Customer Support',
    'projektov√© ≈ô√≠zen√≠': 'Project Management',
    'projektov√Ω management': 'Project Management',
    'avatary': 'Digital Avatars',
    'digit√°ln√≠ avatary': 'Digital Avatars',
    'video': 'Video Creation',
    'video tvorba': 'Video Creation',
    'voiceover': 'Text to Speech',
    'writing assistants': 'Writing Assistants',
    'ai writing': 'AI Writing',
    'content generation': 'Content Generation',
    'writing assistant': 'Writing Assistant'
  }

  return tagMap[normalizedTag] || tag.trim()
}

// Funkce pro odstranƒõn√≠ duplicitn√≠ch tag≈Ø
function removeDuplicateTags(tags: string[]): string[] {
  const normalizedTags = new Set<string>()
  const uniqueTags: string[] = []
  
  tags.forEach(tag => {
    const normalized = normalizeTag(tag).toLowerCase()
    if (!normalizedTags.has(normalized)) {
      normalizedTags.add(normalized)
      uniqueTags.push(normalizeTag(tag)) // P≈ôid√°me normalizovan√Ω tag
    }
  })
  
  return uniqueTags
}

// Funkce pro p≈ô√≠pravu dat kategorie
function prepareProductData(productData: ProductData) {
  // P≈ôipravit tagy - p≈ôidat secondary_category pokud existuje
  let tags = [...productData.tags];
  
  if (productData.secondary_category) {
    // Normalizujeme secondary_category pro srovn√°n√≠
    const normalizedSecondary = normalizeTag(productData.secondary_category).toLowerCase()
    const tagExists = tags.some(tag => normalizeTag(tag).toLowerCase() === normalizedSecondary)
    
    if (!tagExists) {
      tags.unshift(productData.secondary_category); // P≈ôidat na zaƒç√°tek
    }
  }
  
  // Odstranit v≈°echny duplik√°ty
  tags = removeDuplicateTags(tags)

  return {
    ...productData,
    category: productData.primary_category, // Hlavn√≠ kategorie ‚Üí category string
    tags: tags, // Tags vƒçetnƒõ secondary_category, bez duplik√°t≈Ø
    // Odstran√≠me primary_category a secondary_category z fin√°ln√≠ch dat
    primary_category: undefined,
    secondary_category: undefined
  };
}

// POST /api/products/scrape - Automatick√© scrapov√°n√≠ produkt≈Ø z URL
export async function POST(request: NextRequest) {
  try {
    // Kontrola prost≈ôed√≠ - blokace na produkci
    const isAdminUploadEnabled = process.env.NODE_ENV === 'development' || process.env.NEXT_PUBLIC_ENABLE_ADMIN_UPLOAD === 'true'
    
    if (!isAdminUploadEnabled) {
      return NextResponse.json({
        success: false,
        error: 'URL scraping funkcionalita nen√≠ dostupn√° na tomto prost≈ôed√≠'
      }, { status: 403 });
    }

    const { urls } = await request.json();

    if (!urls || !Array.isArray(urls) || urls.length === 0) {
      console.error('‚ùå Chybn√° validace URL:', { urls, isArray: Array.isArray(urls), length: urls?.length });
      return NextResponse.json({ 
        success: false, 
        error: 'Pros√≠m zadejte seznam URL' 
      }, { status: 400 });
    }

    console.log(`üöÄ Zaƒç√≠n√°m scraping pro ${urls.length} URL...`);

    const results = [];

    for (let i = 0; i < urls.length; i++) {
      // Extrakt URL - odstran√≠ ƒç√≠slov√°n√≠, neviditeln√© znaky a jin√© prefixes
      let url = urls[i]?.toString()?.trim();
      
      // Najdi https:// nebo http:// v textu
      const httpMatch = url?.match(/(https?:\/\/[^\s]+)/);
      if (httpMatch) {
        url = httpMatch[1];
      }
      
      if (!url || !url.startsWith('http')) {
        results.push({
          url: url || urls[i] || 'undefined',
          success: false,
          error: 'Neplatn√° URL adresa'
        });
        continue;
      }

      console.log(`üìÑ Zpracov√°v√°m ${i + 1}/${urls.length}: ${url}`);

      try {
        // 1. St√°hnout obsah webov√© str√°nky
        console.log(`üåê Stahuji obsah: ${url}`);
        const websiteContent = await fetchWebsiteContent(url);
        
        if (!websiteContent || websiteContent.trim().length === 0) {
          console.error(`‚ùå Pr√°zdn√Ω obsah: ${url}`);
          results.push({
            url,
            success: false,
            error: 'Sta≈æen√Ω obsah str√°nky je pr√°zdn√Ω'
          });
          continue;
        }

        console.log(`üìÑ Obsah sta≈æen (${websiteContent.length} znak≈Ø)`);

        // 2. Extrahovat data pomoc√≠ OpenAI
        console.log(`ü§ñ Vol√°m OpenAI pro extrakci dat...`);
        const productData = await extractProductData(url, websiteContent);
        
        if (!productData) {
          console.error(`‚ùå OpenAI nevr√°tilo validn√≠ data pro: ${url}`);
          results.push({
            url,
            success: false,
            error: 'Nepoda≈ôilo se extrahovat data produktu nebo nen√≠ AI/tech produkt'
          });
          continue;
        }

        console.log(`‚úÖ Data extrahov√°na: ${productData.name}`);
        
        // 3. P≈ôipravit data s kategoriemi
        const preparedData = prepareProductData(productData);

        // 4. Vytvo≈ôit screenshot
        console.log(`üì∏ Tvo≈ô√≠m screenshot pro: ${productData.name}`);
        const screenshotUrl = await createScreenshot(url, productData.name);
        console.log(`üì∏ Screenshot ${screenshotUrl ? 'vytvo≈ôen' : 'selhal'}: ${screenshotUrl || '≈æ√°dn√° URL'}`);

        // 5. P≈ôidat do review queue (duplik√°ty se kontroluj√≠ p≈ôi approve)
        console.log(`‚úÖ Produkt p≈ôipraven k review: ${productData.name}`);

        results.push({
          url,
          success: true,
          reviewData: {
            ...preparedData,
            externalUrl: url,
            screenshotUrl,
            scrapedAt: new Date().toISOString(),
            reviewId: `review_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
          }
        });

        // Kr√°tk√° pauza mezi requesty
        await new Promise(resolve => setTimeout(resolve, 2000));

      } catch (error) {
        console.error(`‚ùå Chyba p≈ôi zpracov√°n√≠ ${url}:`, error);
        results.push({
          url,
          success: false,
          error: error instanceof Error ? error.message : 'Neoƒçek√°van√° chyba'
        });
      }
    }

    const successCount = results.filter(r => r.success).length;
    const failCount = results.filter(r => !r.success).length;

    console.log(`üéØ Scraping dokonƒçen: ${successCount} √∫spƒõ≈°n√Ωch, ${failCount} ne√∫spƒõ≈°n√Ωch`);

    // P≈ôidat √∫spƒõ≈°n√© produkty do review queue
    const reviewProducts = results
      .filter(r => r.success && r.reviewData)
      .map(r => r.reviewData)

    if (reviewProducts.length > 0) {
      try {
        const reviewResponse = await fetch(`${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/api/review-queue`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ products: reviewProducts })
        })

        const reviewResult = await reviewResponse.json()
        
        if (reviewResult.success) {
          console.log(`üìù ${reviewResult.addedCount} produkt≈Ø p≈ôid√°no do review queue`)
        } else {
          console.warn(`‚ö†Ô∏è Probl√©m s review queue: ${reviewResult.error}`)
        }
      } catch (error) {
        console.error('‚ùå Chyba p≈ôi p≈ôid√°v√°n√≠ do review queue:', error)
      }
    }

    return NextResponse.json({
      success: true,
      totalProcessed: urls.length,
      successCount,
      failCount,
      results,
      reviewQueueAdded: reviewProducts.length
    });

  } catch (error) {
    console.error('‚ùå Kritick√° chyba p≈ôi scrapingu:', error);
    return NextResponse.json({
      success: false,
      error: 'Vnit≈ôn√≠ chyba serveru'
    }, { status: 500 });
  }
}

// St√°hne obsah webov√© str√°nky
async function fetchWebsiteContent(url: string): Promise<string> {
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      signal: AbortSignal.timeout(30000)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const html = await response.text();
    
    // O≈ô√≠znut√≠ HTML na prvn√≠ch 15KB pro AI anal√Ωzu
    return html.substring(0, 15000);

  } catch (error) {
    console.warn(`‚ö†Ô∏è Nepoda≈ôilo se st√°hnout ${url}:`, error);
    return '';
  }
}

// Extrahuje data produktu pomoc√≠ z√°kladn√≠ho HTML parsingu m√≠sto OpenAI
async function extractProductData(url: string, htmlContent: string): Promise<ProductData | null> {
  try {
    console.log(`üîç Extrakcia √∫dajov pre: ${url}`);
    
    // Z√°kladn√≠ HTML parsing
    const titleMatch = htmlContent.match(/<title[^>]*>([^<]+)<\/title>/i);
    const title = titleMatch ? titleMatch[1].trim() : '';
    
    // Hƒæad√°me meta description
    const descMatch = htmlContent.match(/<meta[^>]*name=["']description["'][^>]*content=["']([^"']+)["']/i);
    const description = descMatch ? descMatch[1].trim() : '';
    
    // Hƒæad√°me pr√≠tomnos≈• AI/tech kƒæ√∫ƒçov√Ωch slov
    const content = htmlContent.toLowerCase();
    const aiKeywords = ['ai', 'artificial intelligence', 'machine learning', 'automation', 'api', 'saas', 'tool', 'software', 'platform', 'app'];
    const hasAiKeywords = aiKeywords.some(keyword => content.includes(keyword));
    
    if (!title || !hasAiKeywords) {
      console.log('‚ùå Nen√°jden√© AI/tech kƒæ√∫ƒçov√© slov√° alebo n√°zov');
      return null;
    }
    
    // Z√°kladn√© √∫daje s rozumn√Ωmi predvolbami
    const productData: ProductData = {
      name: title.length > 100 ? title.substring(0, 97) + '...' : title,
      description: description || `AI-powered tool that helps with various tasks. ${title} provides intelligent solutions for better productivity.`,
      primary_category: 'Productivity & Organization', // predvolen√° kateg√≥ria
      secondary_category: 'General Utilities',
      price: 0, // predvolen√° cena
      advantages: [
        'AI-powered functionality',
        'Easy to use interface',
        'Improves productivity',
        'Modern technology'
      ],
      disadvantages: [
        'May require internet connection',
        'Learning curve for advanced features'
      ],
      hasTrial: true, // predpoklad√°me ≈æe m√° trial
      tags: ['AI Tool', 'Productivity', 'Software'],
      detailInfo: description || `${title} is an AI-powered platform designed to enhance productivity and streamline workflows. The tool offers intelligent features that help users achieve their goals more efficiently.`,
      pricingInfo: {
        plans: [
          { name: 'Free', price: 0, features: ['Basic features', 'Limited usage'] },
          { name: 'Pro', price: 29, features: ['Advanced features', 'Unlimited usage', 'Priority support'] }
        ]
      }
    };
    
    console.log(`‚úÖ Extraktovan√© √∫daje pre: ${productData.name}`);
    return productData;
    
  } catch (error) {
    console.error('‚ùå Chyba pri extrakci bez OpenAI:', error);
    return null;
  }
}

// Vytvo≈ô√≠ screenshot homepage
async function createScreenshot(url: string, productName: string): Promise<string | null> {
  try {
    // Vol√°n√≠ Python screenshot API (p≈ôedpokl√°d√°m ≈æe m√°te endpoint)
    const response = await fetch('http://localhost:5000/screenshot', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        url,
        filename: `${productName.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase()}_homepage.png`
      })
    });

    if (response.ok) {
      const result = await response.json();
      return result.screenshotUrl;
    }

    return null;
  } catch (error) {
    console.warn('‚ö†Ô∏è Screenshot se nepoda≈ôilo vytvo≈ôit:', error);
    return null;
  }
} 