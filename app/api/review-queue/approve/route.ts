import { NextRequest, NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Importujeme reviewQueue z hlavn√≠ho API
// V re√°ln√© aplikaci by toto bylo v externe datab√°zi
import type { ReviewProduct } from '../route'

// POST - Schv√°lit produkty a ulo≈æit do datab√°ze
export async function POST(request: NextRequest) {
  try {
    const { reviewIds, action } = await request.json()

    if (!reviewIds || !Array.isArray(reviewIds)) {
      return NextResponse.json({
        success: false,
        error: 'Neplatn√° data - oƒçek√°v√° se pole reviewIds'
      }, { status: 400 })
    }

    // Naƒç√≠st reviewQueue z doƒçasn√©ho √∫lo≈æi≈°tƒõ
    const reviewQueueModule = await import('../route')
    const { getReviewQueue, removeFromReviewQueue } = reviewQueueModule

    const approvedProducts = []
    const failedProducts = []

    for (const reviewId of reviewIds) {
      try {
        // Naj√≠t produkt v review queue
        const reviewProduct = getReviewQueue().find(p => p.reviewId === reviewId)
        
        if (!reviewProduct) {
          failedProducts.push({
            reviewId,
            error: 'Produkt nebyl nalezen v review queue'
          })
          continue
        }

        // Jednoduch√© duplicate check - pouze URL bez koncov√©ho lom√≠tka
        const normalizeUrl = (url: string) => url.replace(/\/$/, '').toLowerCase()
        const cleanUrl = normalizeUrl(reviewProduct.externalUrl)
        
        const existingProduct = await prisma.product.findFirst({
          where: {
            externalUrl: {
              equals: cleanUrl,
              mode: 'insensitive'
            }
          }
        })

        if (existingProduct) {
          failedProducts.push({
            reviewId,
            productName: reviewProduct.name,
            productUrl: reviewProduct.externalUrl,
            error: 'Produkt ji≈æ existuje v datab√°zi',
            existingId: existingProduct.id,
            duplicateReason: 'URL'
          })
          
          // Odebrat duplik√°t z review queue
          removeFromReviewQueue(reviewId)
          console.log(`‚ö†Ô∏è Duplik√°t nalezen: ${reviewProduct.name} (duplicitn√≠ URL)`)
          continue
        }

        console.log(`‚úÖ P≈ôid√°v√°m produkt: ${reviewProduct.name}`)
        console.log(`üìä Data pro ulo≈æen√≠:`, {
          name: reviewProduct.name,
          externalUrl: cleanUrl,
          tags: reviewProduct.tags,
          advantages: reviewProduct.advantages
        })

        // Ulo≈æit do datab√°ze
        const savedProduct = await prisma.product.create({
          data: {
            name: reviewProduct.name,
            description: reviewProduct.description,
            category: reviewProduct.category,
            price: reviewProduct.price,
            imageUrl: reviewProduct.screenshotUrl,
            tags: JSON.stringify(reviewProduct.tags),
            advantages: JSON.stringify(reviewProduct.advantages),
            disadvantages: JSON.stringify(reviewProduct.disadvantages),
            detailInfo: reviewProduct.detailInfo,
            pricingInfo: JSON.stringify(reviewProduct.pricingInfo),
            externalUrl: cleanUrl,
            hasTrial: reviewProduct.hasTrial
          }
        })
        
        console.log(`üíæ Produkt √∫spƒõ≈°nƒõ ulo≈æen do DB:`, savedProduct.id)

        // Odebrat z review queue
        removeFromReviewQueue(reviewId)

        approvedProducts.push({
          reviewId,
          productId: savedProduct.id,
          productName: savedProduct.name
        })

        console.log(`‚úÖ Schv√°len a ulo≈æen produkt: ${savedProduct.name}`)

      } catch (error) {
        console.error(`‚ùå Chyba p≈ôi schvalov√°n√≠ ${reviewId}:`, error)
        failedProducts.push({
          reviewId,
          error: error instanceof Error ? error.message : 'Neoƒçek√°van√° chyba'
        })
      }
    }

    const successCount = approvedProducts.length
    const failCount = failedProducts.length
    const remainingInQueue = getReviewQueue().length

    console.log(`üéØ Schv√°len√≠ dokonƒçeno: ${successCount} √∫spƒõ≈°n√Ωch, ${failCount} ne√∫spƒõ≈°n√Ωch`)

    // API je √∫spƒõ≈°n√© pouze pokud se alespo≈à jeden produkt poda≈ôilo schv√°lit
    const isSuccess = successCount > 0

    return NextResponse.json({
      success: isSuccess,
      approvedCount: successCount,
      failedCount: failCount,
      remainingInQueue,
      approvedProducts,
      failedProducts
    })

  } catch (error) {
    console.error('‚ùå Kritick√° chyba p≈ôi schvalov√°n√≠:', error)
    return NextResponse.json({
      success: false,
      error: 'Vnit≈ôn√≠ chyba serveru'
    }, { status: 500 })
  }
}

// PUT - Aktualizovat produkt v review queue
export async function PUT(request: NextRequest) {
  try {
    const { reviewId, updatedData } = await request.json()

    if (!reviewId || !updatedData) {
      return NextResponse.json({
        success: false,
        error: 'Chyb√≠ reviewId nebo updatedData'
      }, { status: 400 })
    }

    // Naƒç√≠st reviewQueue z doƒçasn√©ho √∫lo≈æi≈°tƒõ
    const reviewQueueModule = await import('../route')
    const { updateInReviewQueue } = reviewQueueModule

    const success = updateInReviewQueue(reviewId, updatedData)

    if (!success) {
      return NextResponse.json({
        success: false,
        error: 'Produkt nebyl nalezen v review queue'
      }, { status: 404 })
    }

    console.log(`üìù Aktualizov√°n produkt v review: ${reviewId}`)

    return NextResponse.json({
      success: true,
      reviewId,
      message: 'Produkt byl √∫spƒõ≈°nƒõ aktualizov√°n'
    })

  } catch (error) {
    console.error('‚ùå Chyba p≈ôi aktualizaci produktu:', error)
    return NextResponse.json({
      success: false,
      error: 'Chyba p≈ôi aktualizaci produktu'
    }, { status: 500 })
  }
} 